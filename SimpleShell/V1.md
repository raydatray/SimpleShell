# Dev Notes
##
Since Rust enforces the concept of ownership, we need to decide which part of the kernel should 

In the original C design, PCBs are only freed 

> In reality, it is possible to replicate the memory model of the original C implementation by utilizing interior mutability (more on that below)
> However, introducing multiple layers of interior mutability would add needless complexity to the project, and 

## Interior Mutability 
<p>
  While running a process, it is possible that we may need to do an LRU cache replacement.
  In order to run a process in the first place, we must first get the PCB that we wish to run from the `all_pcb` map.
  Since we may also need to modify the PCB while it's being ran, we take a mutable reference to it. 

  This poses a challenge, since a cache replacement almost always requires modifying another PCB within from `all_pcb`. 
  (We must invalidate a page from another PCB). However since we have already taken a mutable reference to `all_pcb`, this is impossible.

  To get around this, we need to achieve *interior mutability*, where we can mutate data despite having an immutable reference to it.
  In our single threaded app, this achieveable in Rust through either `Rc` (Reference Counted), `RefCell` (

  We choose `RefCell<T>` to implement interior mutability in our case as we want there to be a single owner of the PCBs (

  ```rust
  let all_pcb = HashMap<usize, PCB>;
  let all_pcb = HashMap<usize, RefCell<PCB>>;
  ```

  Instead of getting a mutable reference to `all_pcb` and then accessing the underlying PCB, we instead get an immutable reference 
  By instead accessing 
</p>
